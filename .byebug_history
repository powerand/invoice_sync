q
imap.fetch(23900, "UIDNEXT")
received_today
imap.fetch(received_today, "UIDNEXT")
imap.fetch("INDEX", ["UIDNEXT", "UIDVALIDITY"])
imap.status("Index", ["UIDNEXT", "UIDVALIDITY"])
imap.status("INDEX", ["UIDNEXT", "UIDVALIDITY"])
imap.status("foldername", ["UIDNEXT", "UIDVALIDITY"])
q
eid
imap.fetch(eid, "BODY")
imap.fetch(eid)
imap.fetch(eid, "ENVELOPE")
imap.fetch(eid, "ENVELOPE")[0].attr["ENVELOPE"]
imap.search(eid)
q
Q
eid
q
imap.search(23903)
imap.methods
imap.find(23903)
imap.fetch(23903)
sdata.to_a[0]
sdata.to_a
sdata.length
sdata.methods
sdata
q
ccc.size
ccc
q
ccc
q
ccc = imap.fetch(received_today, "INTERNALDATE").count do |data|\;puts DateTime.parse(data.attr["INTERNALDATE"])\;end
received_today = imap.search(['ON', Net::IMAP.format_date(Time.now)])
imap.select('INBOX')
ccc = imap.fetch(received_today, "INTERNALDATE").count do |data|\;puts DateTime.parse(data.attr["INTERNALDATE"])\;end
received_today = imap.search(['ON', Net::IMAP.format_date(Time.now)])
ccc = imap.fetch(received_today, "INTERNALDATE").count do |data|\;puts DateTime.parse(data.attr["INTERNALDATE"])\;end
DateTime.parse(data.attr["INTERNALDATE"])
DateTime.parse(data.attr["INTERNALDATE"]) > SEND_AT
ccc = imap.fetch(received_today, "INTERNALDATE").count do |data|\;puts DateTime.parse(data.attr["INTERNALDATE"])\;end
SEND_AT
q
SEND_AT
ccc
q
SEND_AT
DateTime.parse(data.attr["INTERNALDATE"])
q
ccc
q
DateTime.now
DateTime.parse data.attr["INTERNALDATE"]
data.attr["INTERNALDATE"]
puts Date.parse(data.attr["INTERNALDATE"])
Date.parse(data.attr["INTERNALDATE"])
Date.today
Date.methods
Date.current
SEND_AT
Date.parse(data.attr["INTERNALDATE"])
q
SEND_AT
received_today.size
received_today
ccc
q
Date.parse(data.attr["INTERNALDATE"]) < Date.new
Date.parse(data.attr["INTERNALDATE"]) > Date.new
Date.parse(data.attr["INTERNALDATE"]) > Date.nwe
Date.parse(data.attr["INTERNALDATE"]) > Date.now
Date.parse(data.attr["INTERNALDATE"]) > Time.now
Date.parse(data.attr["INTERNALDATE"]).ctime
Date.parse(data.attr["INTERNALDATE"]).time
Date.parse(data.attr["INTERNALDATE"])
q
data.attr["INTERNALDATE"]
data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
data
Time.strftime data.attr["INTERNALDATE"][/\d+:\d+:\d+/]
Time.strptime data.attr["INTERNALDATE"][/\d+:\d+:\d+/]
Time.parse data.attr["INTERNALDATE"][/\d+:\d+:\d+/]
Time.parse data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
Time.parse data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
Time.new data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
data.attr["INTERNALDATE"][/\d+:\d+:\d+ \+\d+/]
data.attr["INTERNALDATE"][/\d+:\d+:\d+/]
data.attr["INTERNALDATE"]
Time.parse data.attr["INTERNALDATE"]
Time.new data.attr["INTERNALDATE"]
data.attr["INTERNALDATE"]
data
data.
data
q
imap.fetch(received_today, "INTERNALDATE")
received_today
q
data
q
Net::IMAP.format_date(Time.now)
Time.now
Net::IMAP.format_date(Date.today)
count = imap.fetch(@received_today, "INTERNALDATE").count{ |data|\;time = DateTime.parse(data.attr["INTERNALDATE"])\; time.between? start_time, end_time}
@received_today = imap.search(["ON", today])
end_time = DateTime.strptime("11:00", "%H:%M")
today = Net::IMAP.format_date(Date.today)
start_time = DateTime.strptime("09:00", "%H:%M")
@received_today = imap.search(["SINCE", start_time, "BEFORE", end_time ]).count
end_time = Net::IMAP.format_datetime(DateTime.strptime("11:00", "%H:%M"))
start_time = Net::IMAP.format_datetime(DateTime.strptime("09:00", "%H:%M"))
require 'date'
imap.search(["SINCE", "20-Feb-2017 09:00 +0000"])
imap.search(["SINCE", "20-Feb-2017 10:10 +0000"])
Net::IMAP.format_datetime(DateTime.strptime("09:00", "%H:%M"))
DateTime.strptime("09:00", "%H:%M")
imap.search(["SINCE", "20-Feb-2017 10-10-10"])
imap.search(["SINCE", "20-Feb-2017 10:10:10"])
imap.search(["SINCE", "20-Feb-2017"])
imap.select("INBOX")
imap.search(["SINCE", "20-Feb-2017"])
imap.search(["SINCE", Net::IMAP.format_datetime(Time.now)])
imap.search("ALL", ["SINCE", Net::IMAP.format_datetime(Time.now)])
imap.search("ALL", "SINCE", Net::IMAP.format_datetime(Time.now))
Net::IMAP.format_datetime(Time.now)
imap.search("SINCE", Net::IMAP.format_datetime(Time.now))
imap = Net::IMAP.new('imap.yandex.ru', 993, ssl: true);imap.login('info@vselampi.ru', 'david391064')
imap.search("SINCE", Net::IMAP.format_datetime(Time.now))
q
response.string
response.status
response.methods
response
q
smtp.enable_ssl
smtp.enable_tls
smtp.ssl
smtp.ssl?
smtp.methods
smtp.starttls?
smtp.starttls
smtp.start_tls
q
imap
q
MYSQL_CLIENTS[@market_index].query("select 12")
q
MYSQL_CLIENTS[@market_index].query("select 12")
q
MYSQL_CLIENTS[@market_index].query("select 12")
q
MYSQL_CLIENTS[@market_index].query("select 12")
MYSQL_CLIENTS[@market_index]
q
MYSQL_CLIENTS[1].query('select 12')
MYSQL_CLIENTS[1].reconnect=true
MYSQL_CLIENTS[1].reconect = true
MYSQL_CLIENTS[1].reconect=true
MYSQL_CLIENTS[1].reconect
MYSQL_CLIENTS[1]
MYSQL_CLIENTS[market_index]
q
MYSQL_CLIENTS[market_index]
MYSQL_CLIENTS[market_index].reconnect=true
MYSQL_CLIENTS[market_index].reconnect=
MYSQL_CLIENTS[market_index].reconnect
MYSQL_CLIENTS[market_index].thread_id
MYSQL_CLIENTS[market_index].last_id
MYSQL_CLIENTS[market_index].async_result
MYSQL_CLIENTS[market_index].server_info
MYSQL_CLIENTS[market_index].automatic_close?
MYSQL_CLIENTS[market_index].automatic_close
MYSQL_CLIENTS[market_index].ping
MYSQL_CLIENTS[market_index].methods
market_index
c
market_index
MYSQL_CLIENTS[market_index]
q
MYSQL_CLIENTS[@market_index].query('select 2')
q
MYSQL_CLIENTS[@market_index].query('select 2')
MYSQL_CLIENTS[@market_index]
@market_index
q
puts err.backtrace
err.backtrace
err
MYSQL_CLIENTS[@market_index].query('select 2').to_a
c
MYSQL_CLIENTS[@market_index].query('select 2').to_a
c
MYSQL_CLIENTS[@market_index].query('select 2').to_a
MYSQL_CLIENTS[@market_index].query('select 2')
@market_index
q
err
q
puts err.backtrace
err.backtrace
err
c
err
q
err
q
MYSQL_CLIENTS[@market_index].query("select 10").to_a
MYSQL_CLIENTS[@market_index].query("select 10")
q
err
q
MYSQL_CLIENTS[@market_index]
MYSQL_CLIENTS[@market_index].query("select 10")
MYSQL_CLIENTS[@market_index].query("select 10"(
c
q
puts err.backtrace
err
c
next
MYSQL_CLIENTS[market_index].query("select 10").to_a
MYSQL_CLIENTS[market_index].query("select 10")
MYSQL_CLIENTS[market_index].automatic_close = false
MYSQL_CLIENTS[market_index]
next
gateway
port
market_name
c
market_name
port
q
port = gateway.open('127.0.0.1', 3306, 3307 + 5)
port = gateway.open('127.0.0.1', 3306, 3307 + 4)
port = gateway.open('127.0.0.1', 3306, 3307 + 3)
port = gateway.open('127.0.0.1', 3306, 3307 + 2)
port = gateway.open('127.0.0.1', 3306, 3307 + 1)
port = gateway.open('127.0.0.1', 3306, 3307 + market_index)
gateway = Net::SSH::Gateway.new(LINUX_HOST[1], LINUX_USER)
Net::SSH::Gateway.new(LINUX_HOST[1], LINUX_USER)
Net::SSH::Gateway.new(LINUX_HOST[market_index], LINUX_USER)
LINUX_USER
LINUX_HOST[1]
MYSQL_CLIENTS[1]
MYSQL_CLIENTS[1].ping
MYSQL_CLIENTS[1].methods
MYSQL_CLIENTS[1].connect
MYSQL_CLIENTS[1].query('select 10').to_a
MARKET_NAMES
MYSQL_CLIENTS[5].query('select 10').to_a
MYSQL_CLIENTS[4].query('select 10').to_a
MYSQL_CLIENTS[3].query('select 10').to_a
MYSQL_CLIENTS[2].query('select 10').to_a
